{"version":3,"file":"ecSimpleOptionPlayer.js","sources":["../src/util.ts","../src/ecSimpleOptionPlayer.ts"],"sourcesContent":["/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nimport { Dictionary } from './types';\n\nexport function assert(condition: any, message?: string) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\nexport function hasOwn(own: object, prop: string): boolean {\n    return own.hasOwnProperty(prop);\n}\n\nexport function isObject<T = unknown>(value: T): value is (object & T) {\n    const type = typeof value;\n    return type === 'function' || (!!value && type === 'object');\n}\n\nexport function isArray(value: any): value is unknown[] {\n    if (Array.isArray) {\n        return Array.isArray(value);\n    }\n    return Object.prototype.toString.call(value) === '[object Array]';\n}\n\nexport function isFunction(value: any): value is Function {\n    return typeof value === 'function';\n}\n\nexport function getMapValue<T>(map: Dictionary<T>, key: string): T {\n    return (key != null && hasOwn(map, key)) ? map[key] : null;\n}\n","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nimport { assert, getMapValue, hasOwn, isArray, isFunction, isObject } from './util';\nimport { EChartsOption, EChartsType } from 'echarts';\nimport { DimensionName } from './types';\n\n/**\n * @usage\n * ```js\n * // Initialize with an array of echarts option info:\n * const player = ecSimpleOptionPlayer.create({\n *\n *     // The echarts instance or chart instance getter.\n *     chart: function () {\n *         return myChart;\n *     },\n *     seriesIndex: 0,\n *     replaceMerge: ['xAxis', 'yAxis']\n *\n *     // The data meta info used to determine how to\n *     // make transition mapping.\n *     // The strategy: If `uniqueDimension` provided and is a common\n *     // dimension, use `uniqueDimension`.\n *     dataMeta: {\n *         aaa: {\n *             dimensions: ['qqq', 'www', 'eee', 'rrr']\n *         },\n *         bbb: {\n *             dimensions: ['ccc', 'www', 'eee'],\n *             uniqueDimension: 'www',\n *             dividingMethod: 'duplicate'\n *         },\n *         ...\n *     },\n *\n *     // echarts option collection:\n *     optionList: [\n *         // dataMetaKey is the key of 'dataMeta'.\n *         { key: 'Time_Income_Bar', option: option0, dataMetaKey: 'aaa' },\n *         { key: 'Population_Income_Scatter', option: option1, dataMetaKey: 'bbb' },\n *         { key: 'Time_Income_Pie', option: option2, dataMetaKey: 'aaa' },\n *         ...\n *     ]\n * });\n *\n * // Then start to play:\n * player.next(); // Display next option (from the first option).\n * player.previous(); // Display previous optoin.\n * player.go('Time_Income_Pie'); // Display the specified option.\n * player.getOptionKeys(); // return `['Time_Income_Bar', 'Population_Income_Scatter', 'Time_Income_Pie']`\n * ```\n */\nexport function create(opt: SimpleOptionPlayerOpt) {\n    return new SimpleOptionPlayer(opt);\n}\n\ntype SimpleOptionPlayerOpt = {\n    chart: SimpleOptionPlayer['_chart'];\n    // Target series index to be transitioned.\n    seriesIndex: number;\n    replaceMerge?: SimpleOptionPlayer['_replaceMerge'];\n    optionList: SimpleOptionPlayer['_optionList'];\n    dataMeta: SimpleOptionPlayer['_dataMeta'];\n};\n\nclass SimpleOptionPlayer {\n\n    private _chart: EChartsType | (() => EChartsType);\n    private _dataMeta: {\n        // An user defined key for a dataMeta.\n        [dataMetaKey in string]: {\n            dimensions: DimensionName[];\n            uniqueDimension?: string;\n            dividingMethod?: 'split' | 'duplicate'\n        }\n    };\n    private _optionList: {\n        // An user defined key for an option.\n        key: string;\n        option: EChartsOption;\n        dataMetaKey: string;\n    }[];\n    private _replaceMerge: (keyof EChartsOption & string)[];\n\n    private _seriesIndex: number;\n\n    private _currOptionIdx: number;\n\n    // value: option index in SimpleOptionPlayer['_optionList'].\n    private _optionMap: { [optionKey: string]: number };\n\n\n    constructor(opt: SimpleOptionPlayerOpt) {\n        assert(\n            opt.chart\n            && isObject(opt.dataMeta)\n            && isArray(opt.optionList)\n            && opt.optionList.length\n        );\n\n        this._chart = opt.chart;\n        this._dataMeta = opt.dataMeta;\n        const optionList = this._optionList = opt.optionList;\n        const optionMap = this._optionMap = {} as SimpleOptionPlayer['_optionMap'];\n        this._replaceMerge = opt.replaceMerge;\n        this._seriesIndex = opt.seriesIndex || 0;\n        this._currOptionIdx = null;\n\n        for (let i = 0; i < optionList.length; i++) {\n            const optionWrap = optionList[i];\n            const optionKey = optionWrap.key;\n            if (optionKey != null) {\n                assert(!hasOwn(optionMap, optionKey), 'option key duplicat: ' + optionKey);\n                optionMap[optionKey] = i;\n            }\n        }\n    }\n\n    next(): void {\n        const optionList = this._optionList;\n        const newOptionIdx = this._currOptionIdx == null\n            ? 0\n            : Math.min(optionList.length - 1, this._currOptionIdx + 1);\n\n        this._doChangeOption(newOptionIdx);\n    };\n\n    previous(): void {\n        const optionList = this._optionList;\n        const newOptionIdx = this._currOptionIdx == null\n            ? optionList.length - 1\n            : Math.max(0, this._currOptionIdx - 1);\n\n        this._doChangeOption(newOptionIdx);\n    }\n\n    go(optionKey: string): void {\n        const newOptionIdx = getMapValue(this._optionMap, optionKey);\n        assert(newOptionIdx != null, 'Can not find option by option key: ' + optionKey);\n\n        this._doChangeOption(newOptionIdx);\n    }\n\n    private _doChangeOption(newOptionIdx: number): void {\n        const optionList = this._optionList;\n        const oldOptionWrap = this._currOptionIdx != null ? optionList[this._currOptionIdx] : null;\n        const newOptionWrap = optionList[newOptionIdx];\n        const dataMeta = this._dataMeta;\n        const targetSeriesIndex = this._seriesIndex;\n\n        let transitionOpt = {\n            // If can not find mapped dimensions, do not make transition animation\n            // by default, becuase this transition probably bring about misleading.\n            to: { seriesIndex: targetSeriesIndex }\n        } as Parameters<EChartsType['setOption']>[1]['transition'];\n\n        if (oldOptionWrap) {\n            const common =\n                findCommonDimension(oldOptionWrap, newOptionWrap)\n                || findCommonDimension(newOptionWrap, oldOptionWrap);\n            if (common != null) {\n                transitionOpt = {\n                    from: {\n                        seriesIndex: targetSeriesIndex,\n                        dimension: common.uniqueDimension\n                    },\n                    to: {\n                        seriesIndex: targetSeriesIndex,\n                        dimension: common.uniqueDimension\n                    },\n                    dividingMethod: common.dividingMethod\n                };\n            }\n        }\n\n        this._currOptionIdx = newOptionIdx;\n\n        this._getChart().setOption(newOptionWrap.option, {\n            replaceMerge: this._replaceMerge,\n            transition: transitionOpt\n        });\n\n        function findCommonDimension(\n            optionWrapA: typeof optionList[number],\n            optionWrapB: typeof optionList[number]\n        ) {\n            const metaA = getMapValue(dataMeta, optionWrapA.dataMetaKey);\n            const metaB = getMapValue(dataMeta, optionWrapB.dataMetaKey);\n            const uniqueDimensionB = metaB.uniqueDimension;\n            if (uniqueDimensionB != null && metaA.dimensions.indexOf(uniqueDimensionB) >= 0) {\n                return {\n                    uniqueDimension: uniqueDimensionB,\n                    dividingMethod: metaB.dividingMethod\n                };\n            }\n        }\n\n    }\n\n    private _getChart(): EChartsType {\n        return isFunction(this._chart) ? this._chart() : this._chart;\n    }\n\n    getOptionKeys(): string[] {\n        const optionKeys = [];\n        const optionList = this._optionList;\n        for (let i = 0; i < optionList.length; i++) {\n            optionKeys.push(optionList[i].key);\n        }\n        return optionKeys;\n    }\n\n}\n"],"names":[],"mappings":"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"}