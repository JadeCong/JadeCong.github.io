{"version":3,"file":"ecSimpleTransform.js","sources":["../src/id.ts","../src/util.ts","../src/aggregate.ts"],"sourcesContent":["/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nimport {\n    DataTransformOption, DimensionDefinitionLoose, DimensionIndex,\n    DimensionName, ExternalDataTransform, OptionSourceDataArrayRows\n} from './types';\n\n/**\n * @usage\n *\n * ```js\n * dataset: [{\n *     source: [\n *         ['aa', 'bb', 'cc', 'tag'],\n *         [12, 0.33, 5200, 'AA'],\n *         [21, 0.65, 8100, 'AA'],\n *         ...\n *     ]\n * }, {\n *     transform: {\n *         type: 'ecSimpleTransform:id',\n *         config: {\n *             dimensionIndex: 4,\n *             dimensionName: 'ID'\n *         }\n *     }\n *     // Then the result data will be:\n *     // [\n *     //     ['aa', 'bb', 'cc', 'tag', 'ID'],\n *     //     [12, 0.33, 5200, 'AA', 0],\n *     //     [21, 0.65, 8100, 'BB', 1],\n *     //     ...\n *     // ]\n * }]\n * ```\n */\n\nexport interface IdTransformOption extends DataTransformOption {\n    type: 'ecSimpleTransform:id';\n    config: {\n        // Mandatory. Specify where to put the new id dimension.\n        dimensionIndex: DimensionIndex;\n        // Optional. If not provided, left the dimension name not defined.\n        dimensionName: DimensionName;\n    };\n}\n\nexport const transform: ExternalDataTransform<IdTransformOption> = {\n\n    type: 'ecSimpleTransform:id',\n\n    transform: function (params) {\n        const upstream = params.upstream;\n        const config = params.config;\n        const dimensionIndex = config.dimensionIndex;\n        const dimensionName = config.dimensionName;\n\n        const dimsDef = upstream.cloneAllDimensionInfo() as DimensionDefinitionLoose[];\n        dimsDef[dimensionIndex] = dimensionName;\n\n        const data = upstream.cloneRawData() as OptionSourceDataArrayRows;\n\n        // TODO: support objectRows\n        for (let i = 0, len = data.length; i < len; i++) {\n            const line = data[i];\n            line[dimensionIndex] = i;\n        }\n\n        return {\n            dimensions: dimsDef,\n            data: data\n        };\n    }\n};\n","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nexport function assert(condition: any, message?: string) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\nexport function hasOwn(own: object, prop: string): boolean {\n    return own.hasOwnProperty(prop);\n}\n\nexport function quantile(ascArr: number[], p: number): number {\n    const H = (ascArr.length - 1) * p + 1;\n    const h = Math.floor(H);\n    const v = +ascArr[h - 1];\n    const e = H - h;\n    return e ? v + e * (ascArr[h] - v) : v;\n}\n","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nimport {\n    DataTransformOption, DimensionLoose, DimensionName, ExternalDataTransform,\n    ExternalDimensionDefinition, ExternalSource, OptionDataValue\n} from './types';\nimport { assert, hasOwn, quantile } from './util';\n\n/**\n * @usage\n *\n * ```js\n * dataset: [{\n *     source: [\n *         ['aa', 'bb', 'cc', 'tag'],\n *         [12, 0.33, 5200, 'AA'],\n *         [21, 0.65, 7100, 'AA'],\n *         [51, 0.15, 1100, 'BB'],\n *         [71, 0.75, 9100, 'BB'],\n *         ...\n *     ]\n * }, {\n *     transform: {\n *         type: 'ecSimpleTransform:aggregate',\n *         config: {\n *             resultDimensions: [\n *                 // by default, use the same name with `from`.\n *                 { from: 'aa', method: 'sum' },\n *                 { from: 'bb', method: 'count' },\n *                 { from: 'cc' }, // method by default: use the first value.\n *                 { from: 'dd', method: 'Q1' },\n *                 { from: 'tag' }\n *             ],\n *             groupBy: 'tag'\n *         }\n *     }\n *     // Then the result data will be:\n *     // [\n *     //     ['aa', 'bb', 'cc', 'tag'],\n *     //     [12, 0.33, 5200, 'AA'],\n *     //     [21, 0.65, 8100, 'BB'],\n *     //     ...\n *     // ]\n * }]\n * ```\n */\n\nexport interface AggregateTransformOption extends DataTransformOption {\n    type: 'ecSimpleTransform:aggregate';\n    config: {\n        // Mandatory\n        resultDimensions: {\n            // Optional. The name of the result dimensions.\n            // If not provided, inherit the name from `from`.\n            name: DimensionName;\n            // Mandatory. `from` is used to reference dimension from `source`.\n            from: DimensionLoose;\n            // Optional. Aggregate method. Currently only these method supported.\n            // If not provided, use `'first'`.\n            method: AggregateMethodLoose;\n        }[];\n        // Optional\n        groupBy: DimensionLoose;\n    };\n}\n\nconst METHOD_INTERNAL = {\n    'SUM': true,\n    'COUNT': true,\n    'FIRST': true,\n    'AVERAGE': true,\n    'Q1': true,\n    'Q2': true,\n    'Q3': true,\n    'MIN': true,\n    'MAX': true\n} as const;\nconst METHOD_NEEDS_COLLECT = {\n    AVERAGE: ['COUNT']\n} as const;\nconst METHOD_NEEDS_GATHER_VALUES = {\n    Q1: true,\n    Q2: true,\n    Q3: true\n} as const;\nconst METHOD_ALIAS = {\n    MEDIAN: 'Q2'\n} as const;\n\ntype AggregateMethodLoose =\n    AggregateMethodInternal\n    | 'sum' | 'count' | 'first' | 'average' | 'Q1' | 'Q2' | 'Q3' | 'median' | 'min' | 'max';\ntype AggregateMethodInternal = keyof typeof METHOD_INTERNAL;\n\n\nclass ResultDimInfoInternal {\n\n    readonly method: AggregateMethodInternal;\n    readonly name: DimensionName;\n    readonly index: number;\n    readonly indexInUpstream: number;\n\n    readonly collectionInfoList = [] as {\n        method: AggregateMethodInternal;\n        indexInLine: number;\n    }[];\n\n    // FIXME: refactor\n    readonly gatheredValuesByGroup: { [groupVal: string]: number[] } = {};\n    readonly gatheredValuesNoGroup = [] as number[];\n    readonly needGatherValues: boolean = false;\n\n    __collectionResult: TravelResult<CollectionResultLine>;\n\n    private _collectionInfoMap = {} as {\n        // number is the index of `list`\n        [method in AggregateMethodInternal]: number\n    };\n\n    constructor(\n        index: number,\n        indexInUpstream: number,\n        method: AggregateMethodInternal,\n        name: DimensionName,\n        needGatherValues: boolean\n    ) {\n        this.method = method;\n        this.name = name;\n        this.index = index;\n        this.indexInUpstream = indexInUpstream;\n        this.needGatherValues = needGatherValues;\n    }\n\n    addCollectionInfo(item: ResultDimInfoInternal['collectionInfoList'][number]) {\n        this._collectionInfoMap[item.method] = this.collectionInfoList.length;\n        this.collectionInfoList.push(item);\n    }\n\n    getCollectionInfo(method: AggregateMethodInternal) {\n        return this.collectionInfoList[this._collectionInfoMap[method]];\n    }\n\n    // FIXME: temp implementation. Need refactor.\n    gatherValue(groupByDimInfo: ExternalDimensionDefinition, groupVal: OptionDataValue, value: OptionDataValue) {\n        // FIXME: convert to number compulsorily temporarily.\n        value = +value;\n        if (groupByDimInfo) {\n            if (groupVal != null) {\n                const groupValStr = groupVal + '';\n                const values = this.gatheredValuesByGroup[groupValStr]\n                    || (this.gatheredValuesByGroup[groupValStr] = []);\n                values.push(value);\n            }\n        }\n        else {\n            this.gatheredValuesNoGroup.push(value);\n        }\n    }\n}\n\ntype CreateInTravel<LINE> = (\n    upstream: ExternalSource,\n    dataIndex: number,\n    dimInfoList: ResultDimInfoInternal[],\n    groupByDimInfo?: ExternalDimensionDefinition,\n    groupByVal?: OptionDataValue\n) => LINE;\ntype UpdateInTravel<LINE> = (\n    upstream: ExternalSource,\n    dataIndex: number,\n    targetLine: LINE,\n    dimInfoList: ResultDimInfoInternal[],\n    groupByDimInfo?: ExternalDimensionDefinition,\n    groupByVal?: OptionDataValue\n) => void;\n\nexport const transform: ExternalDataTransform<AggregateTransformOption> = {\n\n    type: 'ecSimpleTransform:aggregate',\n\n    transform: function (params) {\n        const upstream = params.upstream;\n        const config = params.config;\n\n        const groupByDimInfo = prepareGroupByDimInfo(config, upstream);\n        const { finalResultDimInfoList, collectionDimInfoList } = prepareDimensions(\n            config, upstream, groupByDimInfo\n        );\n\n        // Collect\n        let collectionResult: TravelResult<CollectionResultLine>;\n        if (collectionDimInfoList.length) {\n            collectionResult = travel(\n                groupByDimInfo,\n                upstream,\n                collectionDimInfoList,\n                createCollectionResultLine,\n                updateCollectionResultLine\n            );\n        }\n\n        for (let i = 0; i < collectionDimInfoList.length; i++) {\n            const dimInfo = collectionDimInfoList[i];\n            dimInfo.__collectionResult = collectionResult;\n            // FIXME: just for Q1, Q2, Q3: need asc.\n            asc(dimInfo.gatheredValuesNoGroup);\n\n            const gatheredValuesByGroup = dimInfo.gatheredValuesByGroup;\n            for (const key in gatheredValuesByGroup) {\n                if (hasOwn(gatheredValuesByGroup, key)) {\n                    asc(gatheredValuesByGroup[key]);\n                }\n            }\n        }\n\n        // Calculate\n        const finalResult = travel(\n            groupByDimInfo,\n            upstream,\n            finalResultDimInfoList,\n            createFinalResultLine,\n            updateFinalResultLine\n        );\n\n        const dimensions = [];\n        for (let i = 0; i < finalResultDimInfoList.length; i++) {\n            dimensions.push(finalResultDimInfoList[i].name);\n        }\n\n        return {\n            dimensions: dimensions,\n            data: finalResult.outList\n        };\n    }\n};\n\nfunction prepareDimensions(\n    config: AggregateTransformOption['config'],\n    upstream: ExternalSource,\n    groupByDimInfo: ExternalDimensionDefinition\n): {\n    finalResultDimInfoList: ResultDimInfoInternal[];\n    collectionDimInfoList: ResultDimInfoInternal[];\n} {\n    const resultDimensionsConfig = config.resultDimensions;\n    const finalResultDimInfoList: ResultDimInfoInternal[] = [];\n    const collectionDimInfoList: ResultDimInfoInternal[] = [];\n    let gIndexInLine = 0;\n\n    for (let i = 0; i < resultDimensionsConfig.length; i++) {\n        const resultDimInfoConfig = resultDimensionsConfig[i];\n\n        const dimInfoInUpstream = upstream.getDimensionInfo(resultDimInfoConfig.from);\n        assert(dimInfoInUpstream, 'Can not find dimension by `from`: ' + resultDimInfoConfig.from);\n\n        const rawMethod = resultDimInfoConfig.method;\n\n        assert(\n            groupByDimInfo.index !== dimInfoInUpstream.index || rawMethod == null,\n            `Dimension ${dimInfoInUpstream.name} is the \"groupBy\" dimension, must not have any \"method\".`\n        );\n\n        const method = normalizeMethod(rawMethod);\n        assert(method, 'method is required');\n\n        const name = resultDimInfoConfig.name != null ? resultDimInfoConfig.name : dimInfoInUpstream.name;\n\n        const finalResultDimInfo = new ResultDimInfoInternal(\n            finalResultDimInfoList.length,\n            dimInfoInUpstream.index,\n            method,\n            name,\n            hasOwn(METHOD_NEEDS_GATHER_VALUES, method)\n        );\n        finalResultDimInfoList.push(finalResultDimInfo);\n\n        // For collection.\n        let needCollect = false;\n        if (hasOwn(METHOD_NEEDS_COLLECT, method)) {\n            needCollect = true;\n            const collectionTargetMethods = METHOD_NEEDS_COLLECT[method as keyof typeof METHOD_NEEDS_COLLECT];\n            for (let j = 0; j < collectionTargetMethods.length; j++) {\n                finalResultDimInfo.addCollectionInfo({\n                    method: collectionTargetMethods[j],\n                    indexInLine: gIndexInLine++\n                });\n            }\n        }\n        if (hasOwn(METHOD_NEEDS_GATHER_VALUES, method)) {\n            needCollect = true;\n        }\n        if (needCollect) {\n            collectionDimInfoList.push(finalResultDimInfo);\n        }\n    }\n\n    return { collectionDimInfoList, finalResultDimInfoList };\n}\n\nfunction prepareGroupByDimInfo(\n    config: AggregateTransformOption['config'],\n    upstream: ExternalSource\n): ExternalDimensionDefinition {\n    const groupByConfig = config.groupBy;\n    let groupByDimInfo;\n    if (groupByConfig != null) {\n        groupByDimInfo = upstream.getDimensionInfo(groupByConfig);\n        assert(groupByDimInfo, 'Can not find dimension by `groupBy`: ' + groupByConfig);\n    }\n    return groupByDimInfo;\n}\n\ninterface TravelResult<LINE> {\n    mapByGroup: { [groupVal: string]: LINE };\n    outList: LINE[];\n}\n\nfunction travel<LINE>(\n    groupByDimInfo: ExternalDimensionDefinition,\n    upstream: ExternalSource,\n    resultDimInfoList: ResultDimInfoInternal[],\n    doCreate: CreateInTravel<LINE>,\n    doUpdate: UpdateInTravel<LINE>\n): TravelResult<LINE> {\n    const outList: TravelResult<LINE>['outList'] = [];\n    let mapByGroup: TravelResult<LINE>['mapByGroup'];\n\n    if (groupByDimInfo) {\n        mapByGroup = {};\n\n        for (let dataIndex = 0, len = upstream.count(); dataIndex < len; dataIndex++) {\n            const groupByVal = upstream.retrieveValue(dataIndex, groupByDimInfo.index);\n\n            // PENDING: when value is null/undefined\n            if (groupByVal == null) {\n                continue;\n            }\n\n            const groupByValStr = groupByVal + '';\n\n            if (!hasOwn(mapByGroup, groupByValStr)) {\n                const newLine = doCreate(upstream, dataIndex, resultDimInfoList, groupByDimInfo, groupByVal);\n                outList.push(newLine);\n                mapByGroup[groupByValStr] = newLine;\n            }\n            else {\n                const targetLine = mapByGroup[groupByValStr];\n                doUpdate(upstream, dataIndex, targetLine, resultDimInfoList, groupByDimInfo, groupByVal);\n            }\n        }\n    }\n    else {\n        const targetLine = doCreate(upstream, 0, resultDimInfoList);\n        outList.push(targetLine);\n        for (let dataIndex = 1, len = upstream.count(); dataIndex < len; dataIndex++) {\n            doUpdate(upstream, dataIndex, targetLine, resultDimInfoList);\n        }\n    }\n\n    return { mapByGroup, outList };\n}\n\nfunction normalizeMethod(method: AggregateMethodLoose): AggregateMethodInternal {\n    if (method == null) {\n        return 'FIRST';\n    }\n    let methodInternal = method.toUpperCase() as AggregateMethodInternal;\n    methodInternal = hasOwn(METHOD_ALIAS, methodInternal)\n        ? METHOD_ALIAS[methodInternal as keyof typeof METHOD_ALIAS]\n        : methodInternal;\n    assert(hasOwn(METHOD_INTERNAL, methodInternal), `Illegal method ${method}.`);\n    return methodInternal;\n}\n\n\n\ntype CollectionResultLine = number[];\n\nconst createCollectionResultLine: CreateInTravel<CollectionResultLine> = (\n    upstream, dataIndex, collectionDimInfoList, groupByDimInfo, groupByVal\n) => {\n    const newLine = [] as number[];\n    for (let i = 0; i < collectionDimInfoList.length; i++) {\n        const dimInfo = collectionDimInfoList[i];\n        const collectionInfoList = dimInfo.collectionInfoList;\n        for (let j = 0; j < collectionInfoList.length; j++) {\n            const collectionInfo = collectionInfoList[j];\n            // FIXME: convert to number compulsorily temporarily.\n            newLine[collectionInfo.indexInLine] = +lineCreator[collectionInfo.method](\n                upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\n            );\n        }\n        // FIXME: refactor\n        if (dimInfo.needGatherValues) {\n            const val = upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\n            dimInfo.gatherValue(groupByDimInfo, groupByVal, val);\n        }\n    }\n    return newLine;\n};\n\nconst updateCollectionResultLine: UpdateInTravel<CollectionResultLine> = (\n    upstream, dataIndex, targetLine: number[], collectionDimInfoList, groupByDimInfo, groupByVal\n) => {\n    for (let i = 0; i < collectionDimInfoList.length; i++) {\n        const dimInfo = collectionDimInfoList[i];\n        const collectionInfoList = dimInfo.collectionInfoList;\n        for (let j = 0; j < collectionInfoList.length; j++) {\n            const collectionInfo = collectionInfoList[j];\n            const indexInLine = collectionInfo.indexInLine;\n            // FIXME: convert to number compulsorily temporarily.\n            targetLine[indexInLine] = +lineUpdater[collectionInfo.method](\n                targetLine[indexInLine], upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\n            );\n        }\n        // FIXME: refactor\n        if (dimInfo.needGatherValues) {\n            const val = upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\n            dimInfo.gatherValue(groupByDimInfo, groupByVal, val);\n        }\n    }\n};\n\n\n\ntype FinalResultLine = OptionDataValue[];\n\nconst createFinalResultLine: CreateInTravel<FinalResultLine> = (\n    upstream, dataIndex, finalResultDimInfoList, groupByDimInfo, groupByVal\n) => {\n    const newLine = [];\n    for (let i = 0; i < finalResultDimInfoList.length; i++) {\n        const dimInfo = finalResultDimInfoList[i];\n        const method = dimInfo.method;\n        newLine[i] = isGroupByDimension(groupByDimInfo, dimInfo)\n            ? groupByVal\n            : lineCreator[method](\n                upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\n            );\n    }\n    return newLine;\n};\n\nconst updateFinalResultLine: UpdateInTravel<FinalResultLine> = (\n    upstream, dataIndex, targetLine, finalResultDimInfoList, groupByDimInfo, groupByVal\n) => {\n    for (let i = 0; i < finalResultDimInfoList.length; i++) {\n        const dimInfo = finalResultDimInfoList[i];\n        if (isGroupByDimension(groupByDimInfo, dimInfo)) {\n            continue;\n        }\n        const method = dimInfo.method;\n        targetLine[i] = lineUpdater[method](\n            targetLine[i], upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal\n        );\n    }\n};\n\nfunction isGroupByDimension(\n    groupByDimInfo: ExternalDimensionDefinition,\n    targetDimInfo: ResultDimInfoInternal\n): boolean {\n    return groupByDimInfo && targetDimInfo.indexInUpstream === groupByDimInfo.index;\n}\n\nfunction asc(list: number[]) {\n    list.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst lineCreator: {\n    [key in AggregateMethodInternal]: (\n        upstream: ExternalSource,\n        dataIndex: number,\n        dimInfo: ResultDimInfoInternal,\n        groupByDimInfo: ExternalDimensionDefinition,\n        groupByVal: OptionDataValue\n    ) => OptionDataValue\n} = {\n    'SUM'() {\n        return 0;\n    },\n    'COUNT'() {\n        return 1;\n    },\n    'FIRST'(upstream, dataIndex, dimInfo) {\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\n    },\n    'MIN'(upstream, dataIndex, dimInfo) {\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\n    },\n    'MAX'(upstream, dataIndex, dimInfo) {\n        return upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream);\n    },\n    'AVERAGE'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\n        // FIXME: refactor, bad implementation.\n        const collectLine = groupByDimInfo\n            ? dimInfo.__collectionResult.mapByGroup[groupByVal + '']\n            : dimInfo.__collectionResult.outList[0];\n        return (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number)\n            / collectLine[dimInfo.getCollectionInfo('COUNT').indexInLine];\n    },\n    // FIXME: refactor\n    'Q1'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\n        return lineCreatorForQ(0.25, dimInfo, groupByDimInfo, groupByVal);\n    },\n    'Q2'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\n        return lineCreatorForQ(0.5, dimInfo, groupByDimInfo, groupByVal);\n    },\n    'Q3'(upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\n        return lineCreatorForQ(0.75, dimInfo, groupByDimInfo, groupByVal);\n    }\n};\n\nconst lineUpdater: {\n    [key in AggregateMethodInternal]: (\n        val: OptionDataValue,\n        upstream: ExternalSource,\n        dataIndex: number,\n        dimInfo: ResultDimInfoInternal,\n        groupByDimInfo: ExternalDimensionDefinition,\n        groupByVal: OptionDataValue\n    ) => OptionDataValue\n} = {\n    'SUM'(val, upstream, dataIndex, dimInfo) {\n        // FIXME: handle other types\n        return (val as number) + (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\n    },\n    'COUNT'(val) {\n        return (val as number) + 1;\n    },\n    'FIRST'(val) {\n        return val;\n    },\n    'MIN'(val, upstream, dataIndex, dimInfo) {\n        return Math.min(val as number, upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\n    },\n    'MAX'(val, upstream, dataIndex, dimInfo) {\n        return Math.max(val as number, upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number);\n    },\n    'AVERAGE'(val, upstream, dataIndex, dimInfo, groupByDimInfo, groupByVal) {\n        // FIXME: refactor, bad implementation.\n        const collectLine = groupByDimInfo\n            ? dimInfo.__collectionResult.mapByGroup[groupByVal + '']\n            : dimInfo.__collectionResult.outList[0];\n        return (val as number)\n            + (upstream.retrieveValue(dataIndex, dimInfo.indexInUpstream) as number)\n            / collectLine[dimInfo.getCollectionInfo('COUNT').indexInLine];\n    },\n    'Q1'(val, upstream, dataIndex, dimInfo) {\n        return val;\n    },\n    'Q2'(val, upstream, dataIndex, dimInfo) {\n        return val;\n    },\n    'Q3'(val, upstream, dataIndex, dimInfo) {\n        return val;\n    }\n};\n\nfunction lineCreatorForQ(\n    percent: number,\n    dimInfo: ResultDimInfoInternal,\n    groupByDimInfo: ExternalDimensionDefinition,\n    groupByVal: OptionDataValue\n) {\n    const gatheredValues = groupByDimInfo\n        ? dimInfo.gatheredValuesByGroup[groupByVal + '']\n        : dimInfo.gatheredValuesNoGroup;\n    return quantile(gatheredValues, percent);\n}\n"],"names":["transform"],"mappings":"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"}